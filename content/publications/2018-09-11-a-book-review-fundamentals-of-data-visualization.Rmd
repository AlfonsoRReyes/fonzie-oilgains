---
title: 'A book review: Fundamentals of Data Visualization'
author: Alfonso R. Reyes
date: '2018-09-11'
slug: a-book-review-fundamentals-of-data-visualization
categories:
  - data science
  - visualization of data
tags: []
image: cover-fundamentals_of_data_visualization.jpeg
---

```{r echo = FALSE, message = FALSE}
# run setup script
source("_common.R")

library(dplyr)
library(tidyr)
library(ggforce)
library(ggridges)
library(forcats)
```

```{r}
library(lubridate)
library(forcats)
library(tidyr)
library(ggrepel)
```


I just finished reading the new book on data science called Fundamentals of Data Visualization by **Claus Wilke**. When I say reading I mean going and drill down on the topics that interests me. You cannot really never end reading this kind of book; it is a perennial. We are so fortunate that we can enjoy a book of this quality.

Although the book has been written in `R` with `Rmarkdown`, and the graphics generated with the package `ggplot`, among others, the book is not about `R`; it is about **data visualization**. Or, a guide on to achieve great data visualization.

Here is the cover of the book in [Amazon](https://www.amazon.com/Fundamentals-Data-Visualization-Informative-Compelling/dp/1492031089). It is scheduled to be released on December 8, 2018. Link: https://www.amazon.com/Fundamentals-Data-Visualization-Informative-Compelling/dp/1492031089

I got news of the book in Twitter few months ago. It caught my eye because the book, impressively designed, was written purely in `Rmarkdown`. To be honest, I had no idea that you could achieve publishing quality with `Rmarkdown` and `ggplot2`. Well, here this book is the proof.

If we leave aside `R` for a moment, the great accomplishment of the book is putting together the best practices of data visualization in one corpus, totally oriented to data science.

## Best practices in data visualization
Where do I start? The book is so rich that it would take me days to describe it all. What I will do is reviewing the parts I was most interest in. This is my short list, which by the way is really short compared with the 24 chapters in this book.

* The right plot for the right data
* Putting coordinates at good use
* Handling overlapping
* Managing the data-ink ratio
* 3D plotting is not the answer
* Plots are about telling a story
* The Good, the Bad, and the Ugly. Plus the Wrong


## The right plot for the right data
I have seen in the books and the web various efforts of categorization of plots for presenting data but I haven't found something as compelling as this directory of visualizations. It will quickly point you in the right direction. All of the examples in the directory are plots created with `ggplot2` and real data. None of them have been hand drawn.

```{r}
## general setup code

# theme
theme_plot_icon <- function(bg_color = "#F5F8EA", line_color = "#243400",
                            line_size = .6, font_size = 10) {
  theme_dviz_open() %+replace% theme(
    axis.text.x       = element_blank(),
    axis.text.y       = element_blank(),
    axis.title.x      = element_blank(),
    axis.title.y      = element_blank(),
    #axis.line.x       = element_blank(),
    #axis.line.y       = element_blank(),
    #axis.ticks        = element_blank(),
    axis.line.x       = element_line(size = line_size, color = line_color),
    axis.line.y       = element_line(size = line_size, color = line_color),
    axis.ticks        = element_line(size = line_size, color = line_color),
    axis.ticks.length = grid::unit(4, "pt"),
    legend.position   = "none",
    plot.margin       = margin(2, font_size, font_size, font_size),
    plot.title        = element_text(hjust = 0.5,
                                     family = dviz_font_family_bold,
                                     color = line_color,
                                     size = font_size,
                                     margin = margin(2, 0, 2, 0)),
    plot.background   = element_rect(fill = bg_color)
  )
}

theme_plot_icon_hgrid <- function(bg_color = "#F5F8EA", line_color = "#243400",
                                  line_size = .6, font_size = 10) {
  theme_plot_icon(bg_color, line_color, line_size, font_size) %+replace% theme(
      # make grid lines
      #panel.grid.major.y   = element_line(colour = paste0(line_color, "30"),
      #                                    size = 0.5),

      # remove x axis
      axis.ticks.x        = element_blank(),
      axis.line.x         = element_blank()
  )
}

theme_plot_icon_vgrid <- function(bg_color = "#F5F8EA", line_color = "#243400",
                                  line_size = .6, font_size = 10) {
  theme_plot_icon(bg_color, line_color, line_size, font_size) %+replace% theme(
      # make grid lines
      #panel.grid.major.x   = element_line(colour = paste0(line_color, "30"),
      #                                    size = 0.5),

      # remove y axis
      axis.ticks.y        = element_blank(),
      axis.line.y         = element_blank()
  )
}

theme_plot_icon_blank <- function(bg_color = "#F5F8EA", line_color = "#243400",
                                  line_size = .75, font_size = 10) {
  theme_plot_icon(bg_color, line_color, line_size, font_size) %+replace% theme(
      axis.ticks          = element_blank(),
      axis.line.x         = element_blank(),
      axis.line.y         = element_blank(),
      axis.ticks.length    = grid::unit(0, "pt")
  )
}

# data sets
set.seed(5142)

n <- 15
x <- rnorm(n)
y <- .4*x + .6*rnorm(n)
df_scatter_xy <- data.frame(x, y)

df_one_dist <- data.frame(x = c(rnorm(1000, 1., 1.6), rnorm(300, 4, .4)))

df_one_normal <- data.frame(x = rnorm(20))

df_fractions <- data.frame(y = c(.3, .39, .48, .6, .25, .13, .22, .24, .45, .48, .3, .16),
                 x = factor(rep(1:4, 3)),
                 type = rep(c("A", "B", "C"), each = 4))


set.seed(2474)

n <- 8
x <- rnorm(n)
y <- .4*x + .6*rnorm(n)
z <- .5*x + .3*rnorm(n)
z <- (z - min(z) + 0.1)^2
df_scatter_xyz <- data.frame(x, y, z)


set.seed(5012)
df_multi_amounts <- mutate(df_fractions,
                           y = c(1.0, 1.1, 1.4, 1.2)[x]*y)

n <- 70
df_multi_dist <- data.frame(y = c(rnorm(n, 1, .8), rnorm(n, 2, .7), rnorm(n, 0, .5)),
                 type = rep(c("A", "B", "C"), each = n),
                 number = rep(c(2, 1, 3), each = n))

df_props = data.frame(value = c(55, 30, 15),
                      group = c("A", "B", "C"))

df_one_line <- data.frame(
  x = 1:5,
  y = c(3.1, 3.3, 4.0, 3.8, 4.4)
)

set.seed(9681)
n1 <- 1500/5
n2 <- 800/5
x1 <- rnorm(n1, 0, .7)
y1 <- 2 * x1 + rnorm(n1, 0, .8)

x2 <- rnorm(n2, 0, 0.4)
y2 <- 1.5 * x2 + rnorm(n2, .5, .8)

df_dense_scatter <- na.omit(
  data.frame(
    x = scales::censor(c(x1, x2 + 2.2), c(-2, 4)),
    y = scales::censor(c(y1, y2 + 1.5), c(-3.5, 4.5))
  )
)

df_dense_scatter_sample <- df_dense_scatter[sample(1:nrow(df_dense_scatter), 100),]

df_connected_scatter <- data.frame(
  x = c(1.9, 1.5, 2.2, 3, 3.3, 2.7, 1.7, 1),
  y = c(0.3, -1, -2.0, -0.9, .6, 1.8, 2, 0.7),
  t = 1:8
)

df_paired <- data.frame(
  y = c(6, 5.3, 3.8, 2.8, 2,
        4.3, 6.1, 5.1, 3.3, 2.4),
  x = rep(c("A", "B"), each = 5),
  group = rep(1:5, 2)
)

df_uncertain <- data.frame(
  type = c("A", "B", "C"),
  x = c(1.5, 2.2, 3.4),
  y = c(3.2, 5.1, 3.9),
  dx = c(.25, .3, .35),
  dy = c(.5, .4, .6)
)


# palettes

npal <- 5
# earth-brown
pal_earth_brown <- sequential_hcl(n = npal, h1 = 71, c1 = 80, c2 = 10, l1 = 18, l2 = 97, p1 = 1.5)

# brown-green
pal_brown_green <- sequential_hcl(n = npal, h1 = 86, c1 = 80, c2 = 10, l1 = 18, l2 = 97, p1 = 1.5)

# green-brown
pal_green_brown <- sequential_hcl(n = npal, h1 = -265, c1 = 80, c2 = 10, l1 = 18, l2 = 97, p1 = 1.5)

# burgundy-red
pal_red_brown <- sequential_hcl(n = npal, h1 = 28, c1 = 80, c2 = 10, l1 = 18, l2 = 97, p1 = 1.5)

# brown-red
pal_brown_red <- sequential_hcl(n = npal, h1 = 41, c1 = 80, c2 = 10, l1 = 18, l2 = 97, p1 = 1.5)

# ocean-blue
pal_ocean_blue <- sequential_hcl(n = npal, h1 = 241, c1 = 80, c2 = 10, l1 = 18, l2 = 97, p1 = 1.5)

# steel-blue
pal_steel_blue <- sequential_hcl(n = npal, h1 = 257, c1 = 80, c2 = 10, l1 = 18, l2 = 97, p1 = 1.5)
pal_steel_blue_inv <- sequential_hcl(n = npal, h1 = 257-180, c1 = 80, c2 = 10, l1 = 18, l2 = 97, p1 = 1.5)
```

```{r amounts, fig.width = 8, fig.asp = 1/4, echo=TRUE}
palette <- pal_earth_brown

p1 <- ggplot(df_props, aes(x = group, y = value)) + 
  geom_col(
    position="identity", color = palette[npal],
    fill = palette[3], width = 0.8
  ) +
  scale_y_continuous(limits = c(0, 66), expand = c(0, 0)) +
  scale_fill_manual(values = palette[2:4]) +
  labs(title = "Bars") +
  theme_plot_icon_hgrid(palette[npal], palette[1])

p2 <- ggplot(df_props, aes(x = fct_rev(group), y = value)) + 
  geom_col(position="identity", color = palette[npal], fill = palette[3],
           width = .8) +
  scale_y_continuous(limits = c(0, 66), expand = c(0, 0)) +
  scale_fill_manual(values = palette[2:4]) +
  coord_flip() +
  labs(title = "Bars") +
  theme_plot_icon_vgrid(palette[npal], palette[1])

p3 <- ggplot(filter(df_multi_amounts, x!=4), aes(x, y,
                                   fill=factor(type, levels = c("A", "C", "B")))) + 
  geom_col(position="dodge", color = palette[npal],
           width = .7) +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(0, .7)) +
  scale_fill_manual(values = palette[2:4]) +
  labs(title = "Grouped bars") +
  theme_plot_icon_hgrid(palette[npal], palette[1])

p4 <- ggplot(filter(df_multi_amounts, x!=4), aes(x, y,
                                   fill=factor(type, levels = c("B", "C", "A")))) + 
  geom_col(position="dodge", color = palette[npal],
           width = .7) +
  scale_y_continuous(expand = c(0, 0),
                     limits = c(0, .7)) +
  scale_fill_manual(values = rev(palette[2:4])) +
  coord_flip() +
  labs(title = "Grouped bars") +
  theme_plot_icon_vgrid(palette[npal], palette[1])

p5 <- ggplot(df_multi_amounts, aes(x, y, fill=factor(type, levels = c("B", "C", "A")))) + 
  geom_col(position="stack", color = palette[npal]) +
  scale_y_continuous(limits = c(0, 1.55),
                     expand = c(0, 0)) +
  scale_fill_manual(values = rev(palette[2:4])) +
  labs(title = "Stacked bars") +
  theme_plot_icon_hgrid(palette[npal], palette[1])

p6 <- p5 + coord_flip() + theme_plot_icon_vgrid(palette[npal], palette[1])

p7 <- ggplot(df_props, aes(x = fct_rev(group), y = value)) + 
  geom_point(color = palette[2], size = 3) +
  scale_y_continuous(limits = c(0, 66), expand = c(0, 0)) +
  coord_flip() + 
  labs(title = "Dots") +
  theme_plot_icon_vgrid(palette[npal], palette[1])

p8 <- ggplot(filter(df_multi_amounts, x != 1), aes(x, y = factor(type, levels = c("A", "C", "B")), fill = y)) + 
  geom_tile(color = palette[5], size = 1.5) +
  scale_fill_continuous_sequential(h1 = 71, c1 = 80, c2 = 10, l1 = 18, l2 = 97, p1 = 1.5,
                                   begin = 0.2, end = 0.75) +
  labs(title = "Heatmap") +
  theme_plot_icon_blank(palette[npal], palette[1])

plot_grid(p1, p2, p7, ncol = 4, scale = .9)
```


```{r amounts_multi, fig.width = 8, fig.asp = 1/2, echo=TRUE}
plot_grid(p3, p4, p5, p6, 
          p8, ncol = 4, scale = .9)
```

This code is for the **x-y** relationships:

```{r fig.width = 8, fig.asp = 1/4, echo=TRUE}
palette <- pal_steel_blue

p1 <- ggplot(df_scatter_xy, aes(x, y)) + 
  geom_point(fill = palette[2], color = palette[npal], pch = 21, size = 2.4) + 
  scale_x_continuous(expand = c(.2, 0)) +
  scale_y_continuous(expand = c(.2, 0)) +
  labs(title = "Scatter plot") +
  theme_plot_icon(palette[npal], palette[1])

p2 <- ggplot(df_scatter_xyz, aes(x, y, size = z)) + 
  geom_point(fill = palette[2], color = palette[npal], pch = 21, alpha = 0.7) + 
  scale_x_continuous(expand = c(.2, 0)) +
  scale_y_continuous(expand = c(.2, 0)) +
  scale_radius(range = c(3, 10)) +
  labs(title = "Bubble chart") +
  theme_plot_icon(palette[npal], palette[1])

p3 <- ggplot(spread(df_paired, x, y), aes(A, B)) + 
  geom_abline(slope = 1, intercept = 0, color = palette[3], size = 0.3) + 
  geom_point(
    shape = 21, size = 2.4, stroke = 1,
    fill = palette[2], color = palette[npal]
  ) +
  scale_x_continuous(limits = c(1.5, 6.5)) +
  scale_y_continuous(limits = c(1.5, 6.5)) +
  labs(title = "Paired scatter plot") +
  theme_plot_icon(palette[npal], palette[1])

p4 <- ggplot(df_paired, aes(x, y, group = group)) + 
  geom_line(color = palette[1]) + 
  geom_point(
    shape = 21, size = 2.4, stroke = 1,
    fill = palette[2], color = palette[npal]
  ) +
  scale_x_discrete(expand = c(0, 0.4)) +
  scale_y_continuous(limits = c(1.5, 6.5)) +
  labs(title = "Slopegraph") +
  theme_plot_icon(palette[npal], palette[1]) +
  theme(
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank()
  )

plot_grid(p1, p2, p3, p4, ncol = 4, scale = .9)
```

And, this last one, for contour maps, hex bins and correlograms:

```{r fig.width = 8, fig.asp = 1/4, echo=TRUE}
p5 <- ggplot(df_dense_scatter, aes(x, y)) + 
  geom_density2d(binwidth = 0.02, color = palette[1]) +
  scale_x_continuous(limits = c(-2, 3.6), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-4, 5), expand = c(0, 0)) +
  labs(title = "Density contours") +
  theme_plot_icon(palette[npal], palette[1])

p6 <- ggplot(df_dense_scatter, aes(x, y)) + 
  geom_bin2d(bins = 12, color = palette[npal], size = 0.75) +
  scale_x_continuous(limits = c(-2, 3.6), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-4, 5), expand = c(0, 0)) +
  scale_fill_gradientn(colors = palette[1:(npal-1)]) +
  labs(title = "2D bins") +
  theme_plot_icon(palette[npal], palette[1])

p7 <- ggplot(df_dense_scatter, aes(x, y)) + 
  geom_hex(bins = 12, color = palette[npal], size = 0.75) +
  scale_x_continuous(limits = c(-2, 3.6), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-4, 5), expand = c(0, 0)) +
  scale_fill_gradientn(colors = palette[1:(npal-1)]) +
  labs(title = "Hex bins") +
  theme_plot_icon(palette[npal], palette[1])

cm <- cor(select(mtcars, mpg, hp, drat, wt, qsec))
df_wide <- as.data.frame(cm)
df_long <- stack(df_wide)
names(df_long) <- c("cor", "var1")
df_long <- cbind(df_long, var2 = rep(rownames(cm), length(rownames(cm))))
clust <- hclust(as.dist(1-cm), method="average") 
levels <- clust$labels[clust$order]
df_long$var1 <- factor(df_long$var1, levels = levels)
df_long$var2 <- factor(df_long$var2, levels = levels)
p8 <- ggplot(filter(df_long, as.integer(var1) < as.integer(var2)),
       aes(var1, var2, fill=cor, size = abs(cor))) + 
  geom_point(shape = 21, stroke = 0) + 
  scale_x_discrete(position = "top", name = NULL, expand = c(0, 0.5)) +
  scale_y_discrete(name = NULL, expand = c(0, 0.5)) +
  scale_size_area(max_size = 9, limits = c(0, 0.9), guide = "none") +
  scale_fill_gradient2(high = palette[2], mid = palette[npal], low = pal_steel_blue_inv[2], guide = "none") +
  labs(title = "Correlogram") +
  theme_plot_icon(palette[npal], palette[1])


plot_grid(p5, p6, p7, p8, ncol = 4, scale = .9)
```


Let's just remember the code was not in the spirit of the book; I am just showing the code to satisfy yours and my curiosity. Please, don't tell *Claus Wilke* that I am showing R code here.


## Putting coordinates at good use
With something so simple as the cartesian coordinates, why do we always manage to make silly mistakes? And so, labeling wrong a logarithmic scale, applying the wrong transformation, or lacking the practice for a polar coordinate plot. Or what about plotting geospatial data? With few examples *Claus Wilke* makes it clear and simple. My favorite example is the temperature round the year in different places in **polar coordinates**.

And the code is:

```{r, echo=TRUE}
temps_wide <- filter(ncdc_normals,
                station_id %in% c(
                  "USW00014819", # Chicago, IL 60638
                  "USC00516128", # Honolulu, HI 96813
                  "USW00027502", # Barrow, AK 99723, coldest point in the US
                  "USC00042319", # Death Valley, CA 92328 hottest point in the US
                  "USW00093107", # San Diego, CA 92145
                  "USW00012918", # Houston, TX 77061
                  "USC00427606"  # Salt Lake City, UT 84103
                )) %>%
  mutate(location = fct_recode(factor(station_id),
                               "Chicago" = "USW00014819",
                               "Honolulu" = "USC00516128",
                               "Barrow, AK" = "USW00027502",
                               "Death Valley" = "USC00042319",
                               "San Diego" = "USW00093107",
                               "Houston" = "USW00012918",
                               "Salt Lake City, UT" = "USC00427606")) %>%
  select(-station_id, -flag) %>%
  spread(location, temperature) %>%
  arrange(date)
```

```{r temperature-normals-polar, fig.width = 6, echo=TRUE}
temps_long <- gather(temps_wide, location, temperature, -month, -day, -date) %>%
  filter(location %in% c("Chicago",
                         "Death Valley",
                         "Houston",
                         "San Diego")) %>%
  mutate(location = factor(location, levels = c("Death Valley",
                                                "Houston",
                                                "San Diego",
                                                "Chicago")))

ggplot(temps_long, aes(x = date, y = temperature, color = location)) +
  geom_line(size = 1) +
  scale_x_date(name = "date", expand = c(0, 0)) + 
  scale_y_continuous(limits = c(0, 105), expand = c(0, 0),
                     breaks = seq(-30, 90, by = 30),
                     name = "temperature (°F)") +
  scale_color_OkabeIto(order = c(1:3, 7), name = NULL) +
  coord_polar(theta = "x", start = pi, direction = -1) +
  theme_dviz_grid()
```


## Handling overlapping
This is one is something we deal every day, having to handle overlapping points. The author offers several solutions to this problem: partial transparency, jittering, both managed with careful selection of color and shading; binning data into rectangles and hexagons, using contour lines with shading when we deal with high density points.

## Managing the data-ink ratio
Optimizing ink that goes into non-data visual elements comes from Edward Tufte. And requires a balancing act when not to too far. See with the examples from Wilke's book what I mean by that. On the left we have too much ink for the grids, the legend and the frame. On the right we have too little; no grids, no frame which makes the plot confusing.

> two plots

## 3D plotting is not the answer
We all have fell for this. We love 3D. It impresses everybody. But the question is, are we conveying the message that the data is carrying? Is a 3D plot the right choice? Isn't the data being distorted or more difficult to read? See for yourself.

> 3d plots

The author goes as far as saying that "3D It is unequivocally bad and should be erased from the visual vocabulary of data scientists."

## Plots are about telling a story
I loved this part. What's your format for sharing your discoveries from a dataset?


* **Opening–Challenge–Action–Resolution?** 

* **Lead–Development–Resolution?** 

* **Action–Background–Development–Climax–Ending?** 

Or just,

* **Lead–Development?**

The author borrows from the storytelling patterns of writers to tell a story to apply it in data science. Pretty smart. Regularly, we follow our instincts to frame how we engage with the audience and narrate the challenge and the findings. And many times, we don't do it in articulate fashion. Here is where Wilke shares his experience to make the point. It comes to this:

* How do you plan to tell the story? Borrow from the writers storytelling techniques.
* What figures will you use to tell the story? Select the figures that adjust to your scene setting. Will a figure explain the question and the discoveries?
* Make a figure for the generals. People who take decisions are always busy. * Simplify your figures to show the patterns that you see. Sophistication provided by modern tools may get in your way with figures difficult to digest or understand.
* Build up towards complex figures. Come up with a multiple facet figure and everybody is scratching their heads to comprehend? What about coming first with a portion of it first? A subset.

## The Good, the Bad, the Ugly, and the Wrong
Paraphrasing the Clint Eastwood, spaghetti western The Good, the Bad and the Ugly, the author in his book helps us to identify when a plot lacks a proper design, incorrect formatting, or faulty settings. It will not let you guessing from the text in the book; it will explicitly tell what not to do. The author later explains in the caption why the plot was categorized as that.

> image. two plots.

## A book built with Rmarkdown
As I mentioned before, the author decided not to do this book about code. But impressed as I was from the moment I saw the draft months ago, I peaked inside. I looked under the hood. Every chapter is written in Rmarkdown, uses several libraries and datasets to illustrate the visualization techniques. The code content by itself can teach how to build the right figure. At the time I was also embarked in learning Docker containers to make data science reproducible. So, I decided to clone the repository in GitHub and build the book from the code provided.

In fact, you don't need to do this since the book is available online at http://serialmentor.com/dataviz. The website was generated by the R package `bookdown`.

The purpose of building a `Docker` container is providing all the required packages and operating system libraries so the building process is repeatable and successful every time.

## The Docker container
I will not describe the step-by-step process to build the container; it would make this article long when topic at point is data visualization. I will tell you how to get it and run it.

The Docker container can be pulled from this repository https://hub.docker.com/r/f0nzie/clauswilke.dataviz.2018/ at Docker Hub.

Here is a short summary to install the container in your PC:

Install Docker Toolbox
Test it with a basic "Hello World" example.
Pull the container with:

> code

* Run it with:

> code

* The last line will give you the RStudio web IDE.

Enter the username rstudio and password oilgains to login to RStudio.

* Click on the folder book. See figure below:

> image. RStudio docker

* Click on the project dataviz.Rproj to open the project.

* Click on the tab terminal

> image. RStudio terminal.

* Write this in the terminal:

> code

Press <enter>.

* The book will start to build.

To see the code that gives origin to all the plots in the book, just browse in the same folder for any of the Rmd files. Here are some of them:

> image. Rmd files in RStudio docker


You will have a great learning experience by looking at the plots in the book and seeing the code in the Docker container.

There are many more things to learn from this container. For example, how to build a book with bookdown. But that a matter for another article.






